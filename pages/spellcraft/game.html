<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KrazyPlace ‚Äî Spell craft</title>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <style>
    html, body { height: 100%; margin: 0; display: flex; flex-direction: column; }
    main { flex: 1; }
    .hero { padding: 0.5rem; text-align: center; }
    .container-narrow { max-width: 1000px; margin: auto; }
    .daily-box { background: var(--surface-2); border-radius: var(--border-radius); padding: 1.5rem; margin-top: 1rem; }
    .panel { display:flex; gap:1rem; flex-wrap:wrap; justify-content:center; }
    .fragment, .slot { background: var(--surface-3); border-radius: var(--border-radius, 0.25rem); padding:0.6rem; margin:0.3rem; width:220px; border: 1px solid var(--pico-primary); }
    .monster { background: var(--surface-3); border-radius: var(--border-radius, 0.25rem); padding:0.6rem; margin:0.3rem; width:220px; border: 1px solid darkred; }
    .fragment:hover { transform: scale(1.03); cursor:pointer; }
    .slot { min-height:56px; display:flex; align-items:center; justify-content:center; flex-direction:column; }
    .monster.dead { opacity:0.4; filter:grayscale(0.6); }
    .controls { display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap; }
    .stats { text-align:left; }
    .log { max-height:240px; overflow:auto; white-space:pre-wrap; background:var(--surface-1); padding:0.6rem; border-radius:6px; }
    footer { text-align: center; margin-top: 1rem; border-top: 1px solid var(--surface-3); padding-top: 1rem; }
    .inactive { opacity:0.5; }
  </style>
</head>
<body>

<header class="container container-narrow">
  <nav>
    <ul>
      <li class="logo"><a href="/krazyplace">KrazyPlace</a></li>
      <li><a href="#">Spell craft</a></li>
    </ul>
  </nav>
</header>

<main class="container container-narrow">
<section class="hero">
  <h1>KrazyPlace ‚Äî Spell Craftüí∞</h1>

  <div style="margin: 1rem 0;" class="controls">
    <button id="dailyGameBtn">Partie du jour üåû</button>
    <button id="randomGameBtn">Partie al√©atoire üé≤</button>
  </div>

  <div class="daily-box" id="gameBox" style="display:none;">
    <h3 id="phaseTitle">Phase de s√©lection ‚Äî Choix 1 / 3</h3>

    <div style="display:flex; gap:1rem; flex-wrap:wrap; justify-content:center;">
      <div style="min-width:260px;">
        <h4>Fragments propos√©s</h4>
        <div id="choices" class="panel"></div>
        <p style="text-align:center; margin-top:0.4rem;">
          <small>Clique sur un fragment pour le s√©lectionner.</small>
        </p>
      </div>

      <div style="min-width:300px;">
        <h4>Fragments poss√©d√©s</h4>
        <div id="spellSlots" class="panel"></div>
        <p style="text-align:center;">
          <small>En combat : maximum 3 fragments peuvent √™tre actifs.</small>
        </p>
      </div>

      <div style="min-width:320px;">
        <h4>Vague actuelle</h4>
        <div id="waveInfo"></div>
        <div id="monsters" class="panel" style="margin-top:0.6rem;"></div>
        <div style="margin-top:0.6rem;">
          <p class="stats"><strong>Statistiques :</strong></p>
          <p id="statSpells">Sorts lanc√©s : 0</p>
          <p id="statDamage">D√©g√¢ts totaux (incl. overkill) : 0</p>
        </div>
      </div>
    </div>

    <div class="controls" style="margin-top:1rem;">
      <button id="castBtn">üî• Lancer le sort</button>
    </div>

    <hr>
    <div style="display:flex; gap:1rem; align-items:flex-start;">
      <div style="flex:1;">
        <h4>Journal</h4>
        <div id="log" class="log"></div>
      </div>

      <div style="width:260px;">
        <h4>R√®gles</h4>
        <ul>
          <li>Tu s√©lectionnes 3 fragments (1 parmi 3, trois fois).</li>
          <li>En combat, tu peux activer/d√©sactiver librement tes fragments.</li>
          <li>Tu peux activer au maximum 3 fragments simultan√©ment.</li>
          <li>Apr√®s chaque vague, tu choisis 1 fragment parmi 3 qui s‚Äôajoute √† ton inventaire.</li>
          <li><strong>Feu</strong> : +60 imm√©diats + br√ªlure non cumulable de 15 dmg pendant 3 tours (r√©initialisable si r√©-appliqu√©).</li>
          <li><strong>Poison</strong> : cumulable jusqu'√† 5 stacks ; chaque stack dure 5 tours et inflige son d√©g√¢t chaque d√©but de tour.</li>
          <li><strong>√âclair</strong> : 40 √† la cible, puis 20 √† un autre ennemi al√©atoire.</li>
          <li><strong>Marque</strong> : s'applique au prochain tour uniquement ‚Äî tous les d√©g√¢ts re√ßus ce tour-l√† sont doubl√©s, puis la marque dispara√Æt.</li>
          <li><strong>Critique</strong> : si un fragment critique est actif, chaque autre fragment a 25% de chance de doubler ses d√©g√¢ts.</li>
          <li><strong>AoE</strong> : les autres fragments frappent chaque ennemi, les uns apr√®s les autres.</li>
          <li><strong>√âclat</strong> : attaque basique √† 70 d√©g√¢ts.</li>
        </ul>
      </div>
    </div>
  </div>

  <div id="endGame" style="display:none; margin-top:2rem;">
    <h2 id="endTitle">Fin de partie</h2>
    <p id="endSummary"></p>
  </div>
</section>
</main>

<footer><p>¬© KrazyPlace ‚Äî Spellcraft</p></footer>

<script>
/* ---- PRNG ---- */
function pseudoRandom(seed) {
  let s = seed >>> 0;
  return () => { s = (s * 16807) % 2147483647; return (s - 1) / 2147483646; };
}

/* ---- Fragments ----
 Fields:
 - fire: base immediate (60), burn damage per tick (15), burnDuration 3 (non cumulable)
 - poison: per-stack damage per tick (base), duration 5, max 5 stacks
 - lightning: base immediate (40), bounce 50% -> 20
 - mark: applies mark for next turn
 - crit: enables 25% chance to double other fragment's contributions
 - aoe: makes other fragments hit ALL enemies
 - shard: basic 70
*/
const FRAGMENTS_POOL = [
  { id:'fire', name:'Flamme', desc:'60 imm√©diats + br√ªlure (15 x3, non cumulable)', type:'fire', base:60, burn:15, burnDuration:3 },
  { id:'poison', name:'Poison', desc:'DOT cumulable (max 5), 5 tours', type:'poison', base:30, duration:5 },
  { id:'lightning', name:'Foudre', desc:'40 puis 20 √† un autre ennemi', type:'lightning', base:40, bounce:0.5 },
  { id:'mark', name:'Marque', desc:'Double tous les d√©g√¢ts re√ßus au prochain tour', type:'mark' },
  { id:'crit', name:'Critique', desc:'25% chance que les autres fragments fassent x2', type:'crit', critChance:0.25 },
  { id:'aoe', name:'Onde', desc:'Frappe tous les ennemis', type:'aoe' },
  { id:'shard', name:'√âclat', desc:'Attaque basique 70', type:'damage', base:70 }
];

/* ---- Vagues ---- */
const wavesConfig = [
  { n:3, baseHp:80 },
  { n:3, baseHp:120 },
  { n:4, baseHp:160 },
  { n:4, baseHp:230 },
  { n:5, baseHp:330 }
];

/* ---- State ---- */
let rng, seedGlobal;
let choices = [];
let fragments = [];   // inventaire complet
let waveIndex = 0;
let monsters = [];
let spellsCast = 0;
let totalDamage = 0;

let selectionStep = 0; // 0‚Üí1‚Üí2‚Üí3 initiale, puis 999 = combat mode

/* ---- DOM ---- */
const choicesDiv = document.getElementById('choices');
const slotsDiv = document.getElementById('spellSlots');
const waveInfo = document.getElementById('waveInfo');
const monstersDiv = document.getElementById('monsters');
const logDiv = document.getElementById('log');
const statSpells = document.getElementById('statSpells');
const statDamage = document.getElementById('statDamage');
const phaseTitle = document.getElementById('phaseTitle');

/* ---- Buttons ---- */
document.getElementById('dailyGameBtn').onclick = () => {
  const today = new Date().toISOString().split('T')[0];
  const seed = today.split('').reduce((a,c)=>a+c.charCodeAt(0),0);
  startGame(seed);
};
document.getElementById('randomGameBtn').onclick = () => {
  const seed = Math.floor(Math.random() * 2147483647);
  startGame(seed);
};
document.getElementById('castBtn').onclick = () => castSpell();

/* ---- Core ---- */
function startGame(seed) {
  seedGlobal = seed;
  rng = pseudoRandom(seed);

  choices = [];
  fragments = [];
  waveIndex = 0;
  spellsCast = 0;
  totalDamage = 0;
  monsters = [];
  selectionStep = 0;

  document.getElementById('gameBox').style.display = 'block';
  document.getElementById('endGame').style.display = 'none';

  log('Nouvelle partie');

  generateChoices();
  spawnWave();
  updateStats();
  updatePhaseTitle();
}

function updatePhaseTitle() {
  if (selectionStep < 3)
    phaseTitle.textContent = `Phase de s√©lection ‚Äî Choix ${selectionStep + 1} / 3`;
  else if (selectionStep === 3)
    phaseTitle.textContent = `Choisis 1 fragment bonus parmi 3`;
  else
    phaseTitle.textContent = `Combat ‚Äî Active jusqu‚Äô√† 3 fragments`;
}

function log(text) {
  const time = new Date().toLocaleTimeString();
  logDiv.textContent = `[${time}] ${text}
` + logDiv.textContent;
}

function sampleFromPool() {
  const idx = Math.floor(rng() * FRAGMENTS_POOL.length);
  const base = JSON.parse(JSON.stringify(FRAGMENTS_POOL[idx]));
  base.active = false;
  return base;
}

function generateChoices() {
  choices = [sampleFromPool(), sampleFromPool(), sampleFromPool()];
  renderChoices();
}

function renderChoices() {
  choicesDiv.innerHTML = '';
  choices.forEach((c,i)=>{
    const d = document.createElement('div');
    d.className = 'fragment';
    d.innerHTML = `<strong>${c.name}</strong><br><small>${c.desc}</small>`;
    d.onclick = () => pickFragment(i);
    choicesDiv.appendChild(d);
  });
}

function pickFragment(i) {
  const frag = choices[i];
  fragments.push(frag);
  log(`Tu as obtenu : ${frag.name}`);

  if (selectionStep < 2) {
    selectionStep++;
    generateChoices();
  } else if (selectionStep === 2) {
    selectionStep = 999; // combat mode
    choices = [];
    choicesDiv.innerHTML = '';
  } else if (selectionStep === 3) {
    // fragment bonus after wave
    selectionStep = 999;
    choices = [];
    choicesDiv.innerHTML = '';
  }

  renderFragments();
  updatePhaseTitle();
}

function renderFragments() {
  slotsDiv.innerHTML = '';
  fragments.forEach((f,i)=>{
    const d = document.createElement('div');
    d.className = 'slot ' + (f.active ? '' : 'inactive');

    d.innerHTML = `
      <strong>${f.name}</strong><br>
      <small>${f.desc}</small><br>
      <button data-i='${i}' class="toggleBtn">${f.active ? 'D√©sactiver' : 'Activer'}</button>
    `;

    d.querySelector('.toggleBtn').onclick = (e)=>{
      e.stopPropagation();
      toggleFragment(i);
    };

    slotsDiv.appendChild(d);
  });
}

function toggleFragment(i) {
  const activeCount = fragments.filter(f=>f.active).length;
  if (!fragments[i].active && activeCount >= 3) {
    alert("Tu ne peux activer que 3 fragments maximum !");
    return;
  }
  fragments[i].active = !fragments[i].active;
  renderFragments();
}

/* ---- Combat ---- */

function spawnWave() {
  if (waveIndex >= wavesConfig.length) return endGame(true);

  const cfg = wavesConfig[waveIndex];
  monsters = [];

  for (let i=0;i<cfg.n;i++){
    const hp = Math.floor(cfg.baseHp + rng() * cfg.baseHp * 0.5);
    monsters.push({
      id:i,
      hp,
      maxHp:hp,
      burn: null,      // {damage:15, remaining:3}
      poisons: [],     // array of {damage:base, remaining:5}
      mark: null       // {activeNext:true}
    });
  }

  renderWave();
  log(`Vague ${waveIndex+1} : ${monsters.length} monstres.`);
}

function renderWave() {
  waveInfo.innerHTML = `<strong>Vague ${waveIndex+1} / ${wavesConfig.length}</strong>`;
  monstersDiv.innerHTML = '';

  monsters.forEach((m,i)=>{
    const d = document.createElement('div');
    d.className = 'monster' + (m.hp<=0 ? ' dead' : '');
    const burnText = (m.burn && m.burn.remaining > 0) ? `<br><small>Br√ªlure: ${m.burn.damage} x${m.burn.remaining}</small>` : '';
    const poisonText = (m.poisons && m.poisons.length) ? `<br><small>Poison: ${m.poisons.length} stacks (dur√©es : ${m.poisons.map(p=>p.remaining).join(',')})</small>` : '';
    const markText = (m.mark && m.mark.activeNext) ? `<br><small>Marque active au prochain tour</small>` : '';
    d.innerHTML = `<strong>Monstre #${i+1}</strong><br>HP: ${Math.max(0,m.hp)}/${m.maxHp}` + burnText + poisonText + markText;
    monstersDiv.appendChild(d);
  });
}

function pickTarget() {
  const alive = monsters.filter(m=>m.hp>0);
  if (alive.length===0) return null;
  alive.sort((a,b)=>a.hp-b.hp);
  return alive[0];
}

function applyDOTsAll() {
  let dotDamage = 0;
  monsters.forEach(m=>{
    if (m.hp<=0) return;
    // Br√ªlure : applique au d√©but du tour si pr√©sente (non cumulable)
    if (m.burn && m.burn.remaining > 0) {
      m.hp -= m.burn.damage;
      dotDamage += m.burn.damage;
      m.burn.remaining -= 1;
      if (m.burn.remaining <= 0) m.burn = null;
    }
    // Poisons : appliquer chaque stack
    if (m.poisons && m.poisons.length>0) {
      for (let i = m.poisons.length-1; i>=0; i--) {
        const p = m.poisons[i];
        m.hp -= p.damage;
        dotDamage += p.damage;
        p.remaining -= 1;
        if (p.remaining <= 0) m.poisons.splice(i,1);
      }
    }
  });

  if (dotDamage>0) {
    totalDamage += dotDamage;
    log(`DOTs : ${dotDamage} d√©g√¢ts appliqu√©s au d√©but du tour.`);
    updateStats();
    renderWave();
  }
}

function getAliveIndexes(excludeIdx=null) {
  const arr = [];
  monsters.forEach((m,i)=>{ if (m.hp>0 && i!==excludeIdx) arr.push(i); });
  return arr;
}

function castSpell() {
  if (selectionStep < 3 && selectionStep !== 999) return alert("Tu dois d'abord terminer la s√©lection des 3 fragments.");
  const actives = fragments.filter(f=>f.active);
  if (actives.length === 0) return alert("Active au moins un fragment.");

  // Au d√©but du tour on applique les DOTs (br√ªlure, poison)
  applyDOTsAll();

  const aliveBefore = monsters.filter(m=>m.hp>0).length;
  if (aliveBefore === 0) return log("Aucun ennemi vivant.");

  spellsCast++;
  let damageThisCast = 0;

  // Flags
  const critActive = actives.some(f=>f.type === 'crit');
  const isAoE = actives.some(f=>f.type === 'aoe');

  // Helper to compute per-fragment contribution for a given target (returns damage dealt)
  function applyFragmentToTarget(f, targetIdx) {
    const m = monsters[targetIdx];
    if (!m || m.hp<=0) return 0;
    let dealt = 0;

    // If fragment is crit or aoe special don't directly deal damage themselves except for types below.
    // We'll handle types:
    if (f.type === 'damage') {
      let base = f.base || 0;
      // crit chance for this fragment
      if (critActive && Math.random() /* placeholder */) {}
      // We'll use rng() for crit check
      let fragDamage = base;
      if (critActive && rng() < 0.25) {
        fragDamage *= 2;
        log(`Crit! Le fragment ${f.name} double ses d√©g√¢ts (${fragDamage}).`);
      }
      // Mark doubling (mark applies to next turn only; here we apply doubling if the monster had a mark pending)
      if (m.mark && m.mark.activeNext) {
        fragDamage *= 2;
      }
      const before = m.hp;
      m.hp -= Math.floor(fragDamage);
      dealt += before - Math.max(0,m.hp);
    }
    else if (f.type === 'fire') {
      // immediate base damage
      let fragDamage = f.base || 0;
      if (critActive && rng() < 0.25) {
        fragDamage *= 2;
        log(`Crit! Flamme double ses d√©g√¢ts imm√©diats (${fragDamage}).`);
      }
      if (m.mark && m.mark.activeNext) fragDamage *= 2;
      const before = m.hp;
      m.hp -= Math.floor(fragDamage);
      dealt += before - Math.max(0,m.hp);

      // apply burn: non cumulable ‚Äî if already burning, reset duration
      if (!m.burn || m.burn.remaining <= 0) {
        m.burn = { damage: f.burn, remaining: f.burnDuration };
        log(`Br√ªlure appliqu√©e sur Monstre #${targetIdx+1} (${f.burn} x${f.burnDuration}).`);
      } else {
        // reset remaining to burnDuration
        m.burn.remaining = f.burnDuration;
        log(`Br√ªlure r√©initialis√©e sur Monstre #${targetIdx+1} (${f.burn} x${f.burnDuration}).`);
      }
    }
    else if (f.type === 'poison') {
      // add a poison stack up to 5
      if (!m.poisons) m.poisons = [];
      if (m.poisons.length < 5) {
        m.poisons.push({ damage: f.base, remaining: f.duration });
        log(`Poison appliqu√© sur Monstre #${targetIdx+1} (${f.base} dmg x${f.duration}). Stacks: ${m.poisons.length}`);
      } else {
        // If already 5 stacks, refresh the oldest stack (or ignore). We'll refresh the oldest (FIFO)
        m.poisons.sort((a,b)=>a.remaining - b.remaining);
        m.poisons[0] = { damage: f.base, remaining: f.duration };
        log(`Poison maximum atteint sur Monstre #${targetIdx+1} : on rafra√Æchit une stack (${f.base} x${f.duration}).`);
      }
      // Poison here doesn't do immediate damage (dots start next tick)
    }
    else if (f.type === 'lightning') {
      // hit main target with base
      let fragDamage = f.base || 0;
      if (critActive && rng() < 0.25) {
        fragDamage *= 2;
        log(`Crit! Foudre double son coup (${fragDamage}).`);
      }
      if (m.mark && m.mark.activeNext) fragDamage *= 2;
      const before = m.hp;
      m.hp -= Math.floor(fragDamage);
      dealt += before - Math.max(0,m.hp);

      // bounce to another random alive enemy (excluding this one)
      const others = getAliveIndexes(targetIdx);
      if (others.length > 0) {
        const idx = Math.floor(rng() * others.length);
        const otherIdx = others[idx];
        const second = monsters[otherIdx];
        const bounceDmg = Math.floor((f.base || 0) * f.bounce);
        let finalBounce = bounceDmg;
        if (critActive && rng() < 0.25) {
          finalBounce *= 2;
          log(`Crit sur rebond! La Foudre inflige x2 (${finalBounce}) au Monstre #${otherIdx+1}.`);
        }
        // mark doubling applies on the bounced target too if it had a mark
        if (second.mark && second.mark.activeNext) finalBounce *= 2;
        const before2 = second.hp;
        second.hp -= Math.floor(finalBounce);
        dealt += before2 - Math.max(0, second.hp);
        log(`Foudre rebondit: ${Math.floor(finalBounce)} d√©g√¢ts √† Monstre #${otherIdx+1}.`);
      }
    }
    else if (f.type === 'mark') {
      // apply mark that affects next turn only
      m.mark = { activeNext: true };
      log(`Marque appliqu√©e sur Monstre #${targetIdx+1} (double les d√©g√¢ts re√ßus au prochain tour).`);
    }
    // other types have no additional effect here
    return dealt;
  }

  // If AoE is active: for each enemy, apply effects of non-aoe fragments to every enemy (one after another)
  if (isAoE) {
    // for each alive enemy in order
    monsters.forEach((m, idx) => {
      if (m.hp <= 0) return;
      // For each active fragment (excluding aoe itself), apply to this enemy
      actives.forEach(f => {
        if (f.type === 'aoe') return; // skip
        // Apply fragment to this target and sum damage
        const d = applyFragmentToTarget(f, idx);
        damageThisCast += d;
      });
    });
    log(`Sort AoE : ${damageThisCast} d√©g√¢ts inflig√©s sur tous les ennemis.`);
  } else {
    // Single-target flow: pick primary target (lowest hp) and apply fragments to it
    const primary = pickTarget();
    if (!primary) return log("Aucun ennemi vivant.");
    const primaryIdx = monsters.indexOf(primary);

    // For deterministic application order, apply damage fragments first (so mark doubling affects all fragments in the cast)
    // Apply each active fragment to the target (some like lightning may also affect a second target)
    actives.forEach(f => {
      const d = applyFragmentToTarget(f, primaryIdx);
      damageThisCast += d;
    });

    log(`Sort : ${damageThisCast} d√©g√¢ts inflig√©s (principalement sur Monstre #${primaryIdx+1}).`);
  }

  // After damage applications, any mark that was activeNext should be removed (it only applied for this turn)
  monsters.forEach((m,i)=>{
    if (m.mark && m.mark.activeNext) {
      // The mark's effect applied this turn (or not), but it disappears after this turn regardless
      delete m.mark;
      // Note: The specification says "puis la marque disparaitra, qu'il ai √©t√© frapp√© ou non."
    }
  });

  totalDamage += damageThisCast;

  // After cast, update UI / stats
  renderWave();
  updateStats();

  // Announce kills
  monsters.forEach((m,i)=>{ if (m.hp<=0) log(`Monstre #${i+1} vaincu !`); });

  // Check wave cleared
  const alive = monsters.filter(m=>m.hp>0);
  if (alive.length === 0) {
    log(`Vague ${waveIndex+1} √©limin√©e.`);
    waveIndex++;

    if (waveIndex >= wavesConfig.length) return endGame(true);

    // give player a choice of 1 fragment among 3
    selectionStep = 3;
    phaseTitle.textContent = "Choisis 1 fragment bonus parmi 3";

    generateChoices();
    spawnWave();
  }
}

function updateStats() {
  statSpells.textContent = `Sorts lanc√©s : ${spellsCast}`;
  statDamage.textContent = `D√©g√¢ts totaux : ${totalDamage}`;
}

function endGame(victory) {
  document.getElementById('gameBox').style.display = 'none';
  document.getElementById('endGame').style.display = 'block';

  document.getElementById('endTitle').textContent =
    victory ? 'üèÜ Victoire !' : 'üíÄ D√©faite';

  document.getElementById('endSummary').textContent =
    `Vagues termin√©es : ${Math.min(waveIndex, wavesConfig.length)} / ${wavesConfig.length}.
     Sorts lanc√©s : ${spellsCast}.
     D√©g√¢ts totaux : ${totalDamage}`;

  log("Partie termin√©e.");
}

</script>

</body>
</html>
